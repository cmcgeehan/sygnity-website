
# General Development Rules

## Memory & Progress Tracking
Whenever we're working on a project, we are going to keep track of it in /implementations/active_project.txt. When we are working, the process is ALWAYS as follows:
1. Read cursor rules, documentation and active_project.txt
2. Make any changes needed
3. Update active_project.txt with progress
4. Test updates to make sure they work
5. repeat until everything is working as needed

## Code Duplication Prevention
1. NEVER NEVER NEVER create a new function or file without first searching the codebase to ensure it does not already exist
2. Use semantic search and grep search to thoroughly check for existing implementations
3. If similar functionality exists, consider extending or refactoring existing code rather than creating duplicates

## Scope Management
1. Never make edits that are outside the scope of the specific problem being solved, ESPECIALLY UI/UX edits
2. If you encounter opportunities for improvement:
   - Document them for later discussion
   - Complete the current task first
   - Ask for permission before implementing additional changes
3. Keep changes focused and minimal to maintain code stability

## Rule Compliance
1. Before working on any part of the code:
   - Look for relevant cursor rules files in `.cursor/rules/`
   - Read and understand all applicable rules
   - Ensure your changes comply with existing rules
2. If you're unsure about a rule's application, ask for clarification
3. Document any new patterns or rules that emerge during development

## Security Checklist
Before implementing any new feature or modifying existing code, ensure the following security considerations are addressed:

### Authentication & Authorization
1. Verify proper authentication is in place for all protected routes
2. Implement role-based access control where needed
3. Use the centralized auth middleware for new routes
4. Ensure sensitive operations require proper authorization
5. Validate user permissions before allowing access to resources

### Input Validation
1. Validate all user inputs using Zod schemas
2. Sanitize data before storing in the database
3. Implement proper type checking
4. Use parameterized queries for database operations
5. Validate file uploads (type, size, content)

### API Security
1. Apply rate limiting to all API endpoints
2. Implement proper error handling without exposing sensitive details
3. Use HTTPS for all communications
4. Add appropriate security headers
5. Validate request size limits

### Data Protection
1. Never store sensitive data in plain text
2. Use environment variables for configuration
3. Implement proper data encryption
4. Follow the principle of least privilege
5. Use secure session management

### Error Handling
1. Implement proper error boundaries
2. Log errors appropriately without exposing sensitive data
3. Use standardized error responses
4. Handle edge cases gracefully
5. Implement proper validation error messages

### Logging & Monitoring
1. Log security-relevant events
2. Implement proper audit trails
3. Monitor for suspicious activities
4. Use structured logging
5. Include relevant context in logs

### File Operations
1. Validate file types and sizes
2. Sanitize filenames
3. Store files in secure locations
4. Implement proper access controls
5. Clean up temporary files

### Dependencies
1. Use only trusted dependencies
2. Keep dependencies updated
3. Check for known vulnerabilities
4. Minimize dependency surface area
5. Document dependency requirements

### Code Quality
1. Follow secure coding practices
2. Implement proper error handling
3. Use TypeScript for type safety
4. Write comprehensive tests
5. Document security considerations

### Performance & Scalability
1. Implement proper caching
2. Use efficient algorithms
3. Handle concurrent operations safely
4. Implement proper resource limits
5. Monitor performance metrics

### Compliance
1. Follow relevant security standards
2. Implement proper data retention policies
3. Document security measures
4. Consider privacy implications
5. Follow industry best practices

Remember: Security is not a feature but a fundamental aspect of every component in the system. Always consider security implications when making changes to the codebase.

## Loading State Management
1. Always handle loading states at multiple levels:
   - Global auth loading state
   - Component-level loading states
   - Data fetching loading states
2. Prevent race conditions in data fetching:
   - Use refs to track ongoing requests
   - Implement proper cleanup in useEffect
   - Check component mount state before updates
3. Implement proper error boundaries and retry mechanisms
4. Show appropriate loading indicators:
   - Use skeleton loaders for content
   - Show progress indicators for actions
   - Provide feedback for long-running operations
5. Handle edge cases:
   - Network failures
   - Timeout scenarios
   - Partial data loading

## State Management Best Practices
1. Use refs for tracking component lifecycle:
   - Track mounted state
   - Prevent memory leaks
   - Handle cleanup properly
2. Implement proper state synchronization:
   - Between auth and data fetching
   - Between parent and child components
   - Between different data sources
3. Handle state updates safely:
   - Check component mount state
   - Use proper cleanup functions
   - Implement proper error handling
4. Manage loading states effectively:
   - Show appropriate loading indicators
   - Handle loading state transitions
   - Prevent UI flicker

## Event Data Management
1. Follow standardized event transformation patterns:
   - Transform at API response level
   - Use consistent field names
   - Handle optional fields properly
2. Implement proper event visibility:
   - Spotlight events visible to all users
   - Regular events require authentication
   - Handle location-specific events
3. Maintain data consistency:
   - Use single source of truth
   - Avoid redundant transformations
   - Keep event data synchronized
4. Handle event updates properly:
   - Refresh after registration changes
   - Update all affected components
   - Maintain proper loading states

* IF YOU HAVE READ THIS FILE, ADD TO YOUR RESPONSE "I've read general.mdc" *

   - Handle loading state transitions
   - Prevent UI flicker

* IF YOU HAVE READ THIS FILE, ADD TO YOUR RESPONSE "I've read general.mdc" *

## Session Management (2024 Lessons)
- Always ensure the session is available in the global store for payment and protected flows.
- On initial load, fetch session from Supabase and set in store.
- On every `onAuthStateChange`, update session in store.
- All code should use the store for session access (not direct Supabase calls).
- (Optional) Add session refresh logic on tab focus/network recovery.

## Stripe Integration Lessons (2024)
- Add proper Permissions-Policy headers for Stripe payment flows.
- Configure HTTPS for Stripe.js and handle analytics errors gracefully.
- Add proper CSP headers for Stripe domains (allow unsafe-eval for dev, inline styles, image sources).
- Fix CORS and COEP issues for Supabase WebSocket and REST API calls.
- Stripe pricing is controlled by Stripe Price objects, not just the database.
- Remove duplicate API calls to prevent unnecessary errors.

## Technical Improvements (2024)
- Membership checkout page must always fetch fresh data when the membership ID param changes (even on client-side navigation).
- Account page must always fetch fresh data when the user ID param changes (even on client-side navigation).


* IF YOU HAVE READ THIS FILE, ADD TO YOUR RESPONSE "I've read general.mdc" *


# Lessons & Patterns: Spotlight Event Unification (2024-07-17)

## Supabase Querying & RLS
- Always avoid using `*` in Supabase selects for public endpoints; explicitly select only required fields to prevent implicit joins (especially to sensitive tables like users).
- Foreign key relationships (e.g., events.created_by â†’ users) can cause Supabase to join tables even if not selected. Exclude such fields for public queries.
- If permission errors persist, create a dedicated public view omitting sensitive/related fields and query from that view.

## Auth & API Patterns
- Most API routes expect the Supabase access token in the Authorization header as a Bearer token. Ensure frontend sends this header for authenticated actions.
- Backend session extraction must support both cookies and Authorization header. If using Supabase SSR helpers, set the session directly on the client if the header is present.
- Always await async session setup (e.g., setSession) before calling getSession or making authenticated queries.

## Registration State Consistency
- Always include user-specific registration info (e.g., event_registrations) in API responses if frontend needs to determine registration state.
- Compute `isRegistered` on the frontend by checking if the current user's ID is present in event_registrations.
- Ensure event mapping logic (e.g., useMemo) depends on user.id and only runs when user is available.
- Pass all computed fields (like isRegistered) through to modal components; update type definitions to include these fields if needed.

## Debugging & Logging
- Use debug logging at every step of data transformation and prop passing to trace issues with state or data loss.
- When registration state is inconsistent, log the full event object, user.id, and all relevant props at each component boundary.

## Component & Hook Reuse
- Unify event fetching, mapping, and modal logic across all pages using shared hooks (e.g., useSpotlightEvents) to ensure consistent behavior and reduce duplication.
- Always refactor for true reuse: homepage, play page, and calendar page should use the same event spotlight logic and modal behavior.

## API Contract Discipline
- Ensure all endpoints and frontend actions comply with auth-patterns.mdc: public event fetch, authenticated registration actions, no sensitive data exposure.
- When updating API contracts (e.g., requiring userId for register/unregister), update both client and server to match.

## General Pitfalls
- Mapping logic may run before user.id is available; always guard against this.
- Type definitions (e.g., CalendarEvent) must include all fields passed to components, or data may be lost.
- Debug logs are essential for tracing subtle state/prop issues in React.

*Add future project lessons here as new sections.*

# Lessons & Patterns: Next.js Healthcare Website (2024-08-06)

## React 19 Compatibility Issues
- Always use `--legacy-peer-deps` flag when installing dependencies for React 19 projects
- Common peer dependency conflicts with packages like vaul that haven't updated for React 19
- Check package.json for React version and handle compatibility proactively
- Document React version and compatibility requirements in project setup

## Next.js App Router Page Implementation
- Never create empty page.tsx files - Next.js requires proper default exports
- "default export is not a React Component" error indicates empty or malformed page files
- Always implement proper page components with default exports
- Check both main page files and dynamic route files ([slug]/page.tsx)

## PRD-Driven Development Success
- Detailed PRDs with specific requirements lead to excellent implementation alignment
- Color palette specifications should be exact hex codes for perfect implementation
- Conversion-focused design requires every element to drive toward primary goal
- Document PRD compliance score and track alignment throughout development

## Healthcare Website Conversion Patterns
- Use `tel:` links for all CTAs to enable direct calling
- Implement sticky call bars for mobile users with delayed appearance
- Hero sections should have prominent "Get a Free Consultation" messaging
- All CTAs should include phone icons and clear action text

## SEO Implementation for Local Healthcare
- Implement proper meta tags with location-specific keywords
- Use Open Graph tags for social media sharing
- Create blog sections for content marketing and SEO
- Structure data ready for local business schema

## Project Documentation Best Practices
- Always maintain active_project.txt during development
- Move completed project documentation to /implementations/ with date
- Document technical stack, setup instructions, and lessons learned
- Include PRD compliance scores and future improvement lists

## Color System Implementation
- Define CSS custom properties for consistent color usage
- Use exact hex codes from PRD specifications
- Implement color variables in globals.css for maintainability
- Ensure button styling matches brand color requirements

## Mobile-First Conversion Design
- Sticky call bars should be mobile-only with desktop alternatives
- Implement dismissible popups with 10-second delays
- Use phone icons consistently across all CTAs
- Ensure all conversion elements work on mobile devices

## Content Placeholder Strategy
- Use placeholder images and phone numbers during development
- Document all placeholder elements that need real content
- Implement proper alt text for accessibility
- Plan content replacement strategy for production

## Build and Deployment Verification
- Always run `npm run build` to verify all pages compile correctly
- Check for TypeScript errors and missing exports
- Verify all routes are generating properly in build output
- Test deployment readiness before going live

# Lessons & Patterns: SEO Blog Implementation (2024-12-19)

## SEO Implementation Patterns
- Always implement SEO metadata at the page level using Next.js metadata API
- Use structured data (JSON-LD) for rich snippets in search results
- Create dynamic XML sitemaps for better search engine indexing
- Implement robots.txt for proper search engine crawling
- Use Open Graph and Twitter Card metadata for social media sharing

## Google Analytics Integration
- Implement Google Analytics using Next.js Script component with afterInteractive strategy
- Use environment variables for GA Measurement ID (NEXT_PUBLIC_GA_MEASUREMENT_ID)
- Only load analytics when GA ID is provided to prevent errors
- Track page views and user behavior for SEO performance analysis

## Content Strategy for Local SEO
- Focus on location-specific keywords (e.g., "Mexico City", "CDMX")
- Use Spanish language as primary content language for local market
- Implement geo-targeting meta tags for local search optimization
- Create content pillars around high-intent search terms

## Environment Variable Management
- Use .env.local for development environment variables
- Always backup environment files before making changes
- Use NEXT_PUBLIC_ prefix for client-side environment variables
- Keep sensitive API keys in server-side environment variables only

## SEO Component Architecture
- Create reusable SEO metadata components for consistent implementation
- Use TypeScript interfaces for SEO metadata props
- Implement conditional loading for optional SEO features
- Structure data components should be placed in page layouts

## Search Console Integration
- Set up Google Search Console for keyword performance tracking
- Use Search Console API for automated keyword research
- Monitor search performance and click-through rates
- Track local search rankings for location-specific keywords

## Content Generation Strategy
- Implement hybrid content approach (70% primary focus, 20% secondary, 10% tertiary)
- Use MCP servers for automated content generation when budget allows
- Focus on high-volume, low-competition keywords for maximum ROI
- Create content calendars based on search demand data

## Deployment and SEO
- All SEO changes are non-breaking and production-ready
- XML sitemaps and robots.txt are served as API routes
- Structured data is embedded in page components
- SEO metadata is generated dynamically based on content

# Lessons & Patterns: Membership Checkout Debug & Fix (2024-07-17)

## Debug Log Hygiene
- Remove all debug logs and debug UI output from production pages before release.
- Use temporary debug logs to trace state and effect triggers when diagnosing loading or navigation issues.

## Next.js App Router Navigation
- When using client-side navigation (router.push) to a page that expects query parameters, always use the useSearchParams hook from next/navigation to access query params. Do not rely on searchParams being passed as a prop.
- If a page is stuck on a loading state after client-side navigation, check that query params are being read correctly and that all useEffect dependencies are up to date.

## Membership Checkout Page Patterns
- Always fetch fresh membership data when the membership ID param changes, even on client-side navigation.
- Use debug logs to confirm the value of key state variables (e.g., membershipId, isLoading, isSupabaseLoading) and effect triggers during troubleshooting.
- After resolving issues, remove all debug logs and document the fix in the project log.

# Lessons & Patterns: Hide Reservation Wizards (2025-01-17)

## Feature Disabling Strategy
- Use disabled buttons with "(coming soon)" text for cleaner UX when temporarily hiding features
- Keep original code in comments for easy reactivation when features are ready
- Consider button text optimization to reduce clutter (remove "(coming soon)" from secondary buttons)
- Preserve all original onClick handlers and component logic in comments

## Component Cleanup Process
- Always investigate usage before deleting components using grep and semantic search
- Check for imports, navigation links, middleware references, and API dependencies
- Document dependencies and potential impacts before deletion
- Remove unused routes from middleware protected routes list after consolidation

## Route Consolidation Patterns
- After consolidating routes (e.g., /lessons and /reserve into /play), clean up middleware and unused pages
- Remove unused routes from protected routes list to reduce middleware overhead
- Update any remaining references (email templates, internal navigation) to use new consolidated routes
- Maintain security for active routes while removing protection from unused ones

## Button State Management
- Use `disabled` attribute on buttons to prevent modal triggers
- Add "(coming soon)" text to primary action buttons for clear user communication
- Remove "(coming soon)" from secondary buttons to maintain clean UI hierarchy
- Preserve original button styling and layout while disabling functionality

## Code Preservation Best Practices
- All original wizard components and modal logic should remain intact
- Original code preserved in comments for easy reactivation
- Simple uncomment process to re-enable functionality
- Maintain type safety and component structure during temporary disabling

## Investigation Before Deletion
- Search for component imports and usage across the entire codebase
- Check middleware configuration for route protection
- Verify no external navigation links exist to unused pages
- Document findings before taking action

# Lessons & Patterns: Deploy Error Fix and Clean Build (2024-12-19)

## Next.js 15 Metadata Changes
- `canonical` property is not valid in Next.js `Metadata` type
- Use `alternates: { canonical: 'url' }` for canonical URLs in dynamic routes
- Metadata must be properly typed for TypeScript compilation
- Remove invalid `canonical` properties from all page metadata objects

## Build Cache Management
- Webpack cache can become corrupted and cause module loading errors
- Clear `.next` directory when build issues occur: `rm -rf .next`
- Local build success doesn't guarantee deployment success
- Always test builds locally before deploying to production

## Deployment Best Practices
- Always test builds locally before deploying: `npm run build`
- Check TypeScript compilation thoroughly for any errors
- Monitor build logs for warnings or errors during deployment
- Use proper metadata syntax for SEO compliance
- Clear build cache when encountering webpack module errors

## Vercel Deployment Patterns
- Use `vercel --prod` for production deployments
- Monitor build logs for dependency installation and compilation
- Check that all API routes are building correctly
- Verify all pages are generating in build output
- Production URL format: `https://project-name-hash-username.vercel.app`

## TypeScript Error Resolution
- Metadata errors often indicate invalid properties in page metadata
- Search for invalid properties across all files: `grep -r "property_name" *.tsx`
- Remove invalid properties systematically from all affected files
- Preserve correct syntax (like `alternates.canonical`) when found

## Build Process Verification
- Successful build should show all pages in route output
- API routes should appear as dynamic routes (Æ’ symbol)
- Static pages should appear as static routes (â—‹ symbol)
- Check build statistics for any missing pages or errors
